package ebpf_inet

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/perf"
	"github.com/cilium/ebpf/rlimit"
	"github.com/k8spacket/k8spacket/broker"
	ebpf_tools "github.com/k8spacket/k8spacket/ebpf/tools"
	k8spacket_log "github.com/k8spacket/k8spacket/log"
	plugin_api "github.com/k8spacket/plugin-api/v2"
	"net"
	"os"
	"os/signal"
	"syscall"
)

/*
bpf2go - eBPF bytecode compiler & go files generator
args:
-cc clang - select C compiler
-target native - means get target platform from golang env GOARCH
-type event - name of type in C ebpf program to generate Go declaration
bpf - identity name of generating program
./bpf/inet.bpf.c - C language source file
*/
//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc clang -target native -type event bpf ./bpf/inet.bpf.c

func Init() {

	k8spacket_log.LOGGER.Printf("INIT inet")
	// Allow the current process to lock more memory than the default for eBPF resources. Default value is 64KB
	// https://prototype-kernel.readthedocs.io/en/latest/bpf/troubleshooting.html#memory-ulimits
	// requires on kernels < 5.11 to remove memlock (error: failed to set memlock rlimit: operation not permitted)
	if err := rlimit.RemoveMemlock(); err != nil {
		k8spacket_log.LOGGER.Printf("[inet] Remove memlock: %v", err)
	}

	// Load pre-compiled programs and maps into the kernel.
	objs := bpfObjects{}
	if err := loadBpfObjects(&objs, nil); err != nil {
		k8spacket_log.LOGGER.Printf("[inet] Loading objects: %v", err)
	}
	defer objs.Close()

	// attach the eBPF program to the tracepoint sock/inet_sock_set_state
	ln, err := link.Tracepoint("sock", "inet_sock_set_state", objs.bpfPrograms.InetSockSetState, nil)
	if err != nil {
		k8spacket_log.LOGGER.Printf("[inet] Cannot attach tracepoint: %v", err)
	}
	defer ln.Close()

	// create new reader for perf events
	rd, err := perf.NewReader(objs.bpfMaps.Events, os.Getpagesize())
	if err != nil {
		k8spacket_log.LOGGER.Printf("[inet] Creating perf event reader: %s", err)
	}
	defer rd.Close()

	go func() {
		// bpfEvent is generated by bpf2go and represents perf event type in eBPF program
		var event bpfEvent
		for {
			record, err := rd.Read()
			if err != nil {
				if errors.Is(err, perf.ErrClosed) {
					k8spacket_log.LOGGER.Println("[inet] Received signal, exiting..")
					return
				}
				k8spacket_log.LOGGER.Printf("[inet] Reading from reader: %s", err)
				continue
			}

			// Parse the perf event into a go bpfEvent structure.
			if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &event); err != nil {
				k8spacket_log.LOGGER.Printf("[inet] Parsing perf event: %s", err)
				continue
			}

			distribute(event)
		}
	}()

	// graceful shutdown
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()

	<-ctx.Done()

	k8spacket_log.LOGGER.Println("[inet] Closed gracefully")
}

func distribute(event bpfEvent) {
	tcpEvent := plugin_api.TCPEvent{
		Client: plugin_api.Address{
			Addr: intToIP4(event.Saddr),
			Port: event.Sport},
		Server: plugin_api.Address{
			Addr: intToIP4(event.Daddr),
			Port: event.Dport},
		TxB:     event.TxB,
		RxB:     event.RxB,
		DeltaUs: event.DeltaUs / 1000}
	ebpf_tools.EnrichAddress(&tcpEvent.Client)
	ebpf_tools.EnrichAddress(&tcpEvent.Server)

	broker.TCPEvent(tcpEvent)
}

func intToIP4(ipNum uint32) string {
	ip := make(net.IP, 4)
	binary.LittleEndian.PutUint32(ip, ipNum)
	return ip.String()
}
