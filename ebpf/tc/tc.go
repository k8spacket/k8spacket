package ebpf_tc

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/k8spacket/k8spacket/broker"
	ebpf_tools "github.com/k8spacket/k8spacket/ebpf/tools"
	k8spacket_log "github.com/k8spacket/k8spacket/log"
	plugin_api "github.com/k8spacket/plugin-api/v2"
	"github.com/vishvananda/netlink"
	"golang.org/x/sys/unix"
	"net"
	"os"
	"os/signal"
	"syscall"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go tc ./bpf/tc.bpf.c

func Init(iface string) {

	// Load pre-compiled programs and maps into the kernel.
	objs := tcObjects{}
	if err := loadTcObjects(&objs, nil); err != nil {
		k8spacket_log.LOGGER.Fatalf("[tc] Loading objects: %v", err)
	}
	defer objs.Close()

	// get the file descriptor of the tc_filter program
	progFd := objs.tcPrograms.TcFilter.FD()

	// get link device by name (network interface name)
	link, err := netlink.LinkByName(iface)
	if err != nil {
		k8spacket_log.LOGGER.Fatalf("[tc] Cannot find %s: %v", iface, err)
	}

	// qdisc clsact - queueing discipline (qdisc) parent of ingress and egress filters
	attrs := netlink.QdiscAttrs{
		LinkIndex: link.Attrs().Index,
		Handle:    netlink.MakeHandle(0xffff, 0),
		Parent:    netlink.HANDLE_CLSACT,
	}

	qdisc := &netlink.GenericQdisc{
		QdiscAttrs: attrs,
		QdiscType:  "clsact",
	}

	// try to delete previous added clsact qdisc on specific network interface, equivalent `tc qdisc del dev {{iface}} clsact`
	if err := netlink.QdiscDel(qdisc); err != nil {
		k8spacket_log.LOGGER.Printf("[tc] Cannot del clsact qdisc: %v", err)
	}

	// add clsact qdisc on specific network interface, equivalent `tc qdisc add dev {{iface}} clsact`
	// check `qdisc show dev {{iface}}`
	if err := netlink.QdiscAdd(qdisc); err != nil {
		k8spacket_log.LOGGER.Fatalf("[tc] Cannot add clsact qdisc: %v", err)
	}

	// add ingress filter
	addFilter(link, progFd, netlink.HANDLE_MIN_INGRESS)

	// add egress filter
	addFilter(link, progFd, netlink.HANDLE_MIN_EGRESS)

	// create new reader for ringbuf events
	rd, err := ringbuf.NewReader(objs.OutputEvents)
	if err != nil {
		k8spacket_log.LOGGER.Fatalf("[tc] Creating perf event reader: %s", err)
	}
	defer rd.Close()

	go func() {
		// tcTlsHandshakeEvent is generated by bpf2go and represents ringbuf event type in eBPF program
		var event tcTlsHandshakeEvent
		for {
			record, err := rd.Read()
			if err != nil {
				if errors.Is(err, ringbuf.ErrClosed) {
					k8spacket_log.LOGGER.Println("[tc] Received signal, exiting..")
					return
				}
				k8spacket_log.LOGGER.Printf("[tc] Reading from reader: %s", err)
				continue
			}

			// Parse the ringbuf event into a tcTlsHandshakeEvent structure.
			if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.BigEndian, &event); err != nil {
				k8spacket_log.LOGGER.Printf("[tc] Parsing ringbuf event: %s", err)
				continue
			}

			distribute(event)
		}
	}()

	// graceful shutdown
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()

	<-ctx.Done()

	k8spacket_log.LOGGER.Println("[tc] Closed gracefully")
}

func addFilter(link netlink.Link, programFD int, parent uint32) {

	// filter attrs
	filterAttrs := netlink.FilterAttrs{
		LinkIndex: link.Attrs().Index,
		Parent:    parent,
		Handle:    netlink.MakeHandle(0, 1),
		Protocol:  unix.ETH_P_ALL,
		Priority:  1,
	}

	// bpf filter struct
	filter := &netlink.BpfFilter{
		FilterAttrs:  filterAttrs,
		Fd:           programFD,
		Name:         "tc",
		DirectAction: true,
	}

	// add ingress/egress filter, equivalent `tc filter add dev {{iface}} [ingress|egress]`
	// check `tc filter show dev {{iface}} [ingress|egress]`
	if err := netlink.FilterAdd(filter); err != nil {
		k8spacket_log.LOGGER.Fatalf("[tc] Cannot attach bpf object to filter: %v", err)
	}
}

func distribute(event tcTlsHandshakeEvent) {
	tlsEvent := plugin_api.TLSEvent{
		Client: plugin_api.Address{
			Addr: intToIP4(event.Saddr),
			Port: event.Sport},
		Server: plugin_api.Address{
			Addr: intToIP4(event.Daddr),
			Port: event.Dport},
		TlsVersions:    event.TlsVersions[:int(event.TlsVersionsLength)/2],
		Ciphers:        event.Ciphers[:int(event.CiphersLength)/2],
		ServerName:     string(event.ServerName[:event.ServerNameLength]),
		UsedTlsVersion: event.UsedTlsVersion,
		UsedCipher:     event.UsedCipher}
	ebpf_tools.EnrichAddress(&tlsEvent.Client)
	ebpf_tools.EnrichAddress(&tlsEvent.Server)
	broker.TLSEvent(tlsEvent)
}

func intToIP4(ipNum uint32) string {
	ip := make(net.IP, 4)
	binary.BigEndian.PutUint32(ip, ipNum)
	return ip.String()
}
