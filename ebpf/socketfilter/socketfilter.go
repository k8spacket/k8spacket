package ebpf_socketfilter

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"github.com/cilium/ebpf"
	"log"
	"log/slog"
	"net"
	"os"
	"os/signal"
	"syscall"

	"github.com/cilium/ebpf/perf"
	"github.com/k8spacket/k8spacket/broker"
	ebpf_tools "github.com/k8spacket/k8spacket/ebpf/tools"
	"github.com/k8spacket/k8spacket/modules"
	"golang.org/x/sys/unix"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -go-package ebpf_socketfilter socketfilter ./bpf/socketfilter.bpf.c

type SocketFilterEbpf struct {
	Broker broker.IBroker
}

func (socketFilterEbpf *SocketFilterEbpf) Init() {

	// Load pre-compiled programs and maps into the kernel.
	objs := bpfObjects{}
	if err := loadBpfObjects(&objs, nil); err != nil {
		var verr *ebpf.VerifierError
		if errors.As(err, &verr) {
			log.Fatalf("loading objects: %+v\n", verr)
		} else {
			log.Fatalf("loading objects: %v", err)
		}
	}
	defer objs.Close()

	fd, err := unix.Socket(unix.AF_PACKET, unix.SOCK_RAW, int(htons(unix.ETH_P_ALL)))
	println(fd)
	if err == nil {
		println(objs.SocketHttpFilter.FD())
		ssoErr := unix.SetsockoptInt(fd, unix.SOL_SOCKET, unix.SO_ATTACH_BPF, objs.SocketHttpFilter.FD())
		if ssoErr != nil {
			panic(ssoErr)
		}
	} else {
		panic(err)
	}

	// create new reader for perf events
	rd, err := perf.NewReader(objs.OutputEvents, os.Getpagesize())
	if err != nil {
		slog.Error("[tc] Creating perf event reader", "Error", err)
	}
	defer rd.Close()

	go func() {
		// tcTlsHandshakeEvent is generated by bpf2go and represents perf event type in eBPF program
		var event tcTlsHandshakeEvent
		for {
			record, err := rd.Read()
			if err != nil {
				if errors.Is(err, perf.ErrClosed) {
					slog.Info("[tc] Received signal, exiting..")
					return
				}
				slog.Error("[tc] Reading from reader", "Error", err)
				continue
			}

			// Parse the perf event into a tcTlsHandshakeEvent structure.
			if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.BigEndian, &event); err != nil {
				slog.Error("[tc] Parsing perf event", "Error", err)
				continue
			}

			distribute(event, tcEbpf)
		}
	}()

	// graceful shutdown
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()

	<-ctx.Done()

	slog.Info("[tc] Closed gracefully")
}

func distribute(event tcTlsHandshakeEvent, tc *TcEbpf) {

	tlsVersionsLen := int(event.TlsVersionsLength) / 2
	if tlsVersionsLen > len(event.TlsVersions) {
		tlsVersionsLen = len(event.TlsVersions)
	}

	ciphersLen := int(event.CiphersLength) / 2
	if ciphersLen > len(event.Ciphers) {
		ciphersLen = len(event.Ciphers)
	}

	serverNameLen := int(event.ServerNameLength)
	if serverNameLen > len(event.ServerName) {
		serverNameLen = len(event.ServerName)
	}

	tlsEvent := modules.TLSEvent{
		Client: modules.Address{
			Addr: intToIP4(event.Saddr),
			Port: event.Sport},
		Server: modules.Address{
			Addr: intToIP4(event.Daddr),
			Port: event.Dport},
		TlsVersions:    event.TlsVersions[:tlsVersionsLen],
		Ciphers:        event.Ciphers[:ciphersLen],
		ServerName:     string(event.ServerName[:serverNameLen]),
		UsedTlsVersion: event.UsedTlsVersion,
		UsedCipher:     event.UsedCipher}
	if len(tlsEvent.TlsVersions) <= 0 {
		tlsEvent.TlsVersions = append(tlsEvent.TlsVersions, event.TlsVersion)
	}

	ebpf_tools.EnrichAddress(&tlsEvent.Client)
	ebpf_tools.EnrichAddress(&tlsEvent.Server)
	tc.Broker.TLSEvent(tlsEvent)
}

func intToIP4(ipNum uint32) string {
	ip := make(net.IP, 4)
	binary.BigEndian.PutUint32(ip, ipNum)
	return ip.String()
}
