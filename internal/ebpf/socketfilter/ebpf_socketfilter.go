package ebpf_socketfilter

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"log"
	"log/slog"
	"net"
	"os"
	"os/signal"
	"syscall"
	"unsafe"

	"github.com/cilium/ebpf"

	"github.com/cilium/ebpf/perf"
	"github.com/k8spacket/k8spacket/internal/broker"
	ebpf_tools "github.com/k8spacket/k8spacket/internal/ebpf/tools"
	"github.com/k8spacket/k8spacket/internal/modules"
	"golang.org/x/sys/unix"
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -go-package ebpf_socketfilter socketfilter ./bpf/socketfilter.bpf.c

type EbpfSocketFilter struct {
	Broker broker.Broker
}

func (ebpfSocketFilter *EbpfSocketFilter) Init() {

	// Load pre-compiled programs and maps into the kernel.
	objs := socketfilterObjects{}
	if err := loadSocketfilterObjects(&objs, nil); err != nil {
		var verr *ebpf.VerifierError
		if errors.As(err, &verr) {
			log.Fatalf("loading objects: %+v\n", verr)
		} else {
			log.Fatalf("loading objects: %v", err)
		}
	}
	defer objs.Close()

	fd, err := unix.Socket(unix.AF_PACKET, unix.SOCK_RAW, int(htons(unix.ETH_P_ALL)))
	if err == nil {
		ssoErr := unix.SetsockoptInt(fd, unix.SOL_SOCKET, unix.SO_ATTACH_BPF, objs.SocketHttpFilter.FD())
		if ssoErr != nil {
			panic(ssoErr)
		}
	} else {
		panic(err)
	}

	// create new reader for perf events
	rd, err := perf.NewReader(objs.OutputEvents, os.Getpagesize())
	if err != nil {
		slog.Error("[socketfilter] Creating perf event reader", "Error", err)
	}
	defer rd.Close()

	go func() {
		// socketfilterTlsHandshakeEvent is generated by bpf2go and represents perf event type in eBPF program
		var event socketfilterTlsHandshakeEvent
		for {
			record, err := rd.Read()
			if err != nil {
				if errors.Is(err, perf.ErrClosed) {
					slog.Info("[socketfilter] Received signal, exiting..")
					return
				}
				slog.Error("[socketfilter] Reading from reader", "Error", err)
				continue
			}

			// Parse the perf event into a socketfilterTlsHandshakeEvent structure.
			if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.BigEndian, &event); err != nil {
				slog.Error("[socketfilter] Parsing perf event", "Error", err)
				continue
			}

			distribute(event, ebpfSocketFilter)
		}
	}()

	// graceful shutdown
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()

	<-ctx.Done()

	slog.Info("[socketfilter] Closed gracefully")
}

func distribute(event socketfilterTlsHandshakeEvent, ebpfSocketFilter *EbpfSocketFilter) {

	tlsVersionsLen := int(event.TlsVersionsLength) / 2
	if tlsVersionsLen > len(event.TlsVersions) {
		tlsVersionsLen = len(event.TlsVersions)
	}

	ciphersLen := int(event.CiphersLength) / 2
	if ciphersLen > len(event.Ciphers) {
		ciphersLen = len(event.Ciphers)
	}

	serverNameLen := int(event.ServerNameLength)
	if serverNameLen > len(event.ServerName) {
		serverNameLen = len(event.ServerName)
	}

	tlsEvent := modules.TLSEvent{
		Source: modules.SocketFilter,
		Client: modules.Address{
			Addr: intToIP4(event.Saddr),
			Port: event.Sport},
		Server: modules.Address{
			Addr: intToIP4(event.Daddr),
			Port: event.Dport},
		TlsVersions:    event.TlsVersions[:tlsVersionsLen],
		Ciphers:        event.Ciphers[:ciphersLen],
		ServerName:     string(event.ServerName[:serverNameLen]),
		UsedTlsVersion: event.UsedTlsVersion,
		UsedCipher:     event.UsedCipher}
	if len(tlsEvent.TlsVersions) <= 0 {
		tlsEvent.TlsVersions = append(tlsEvent.TlsVersions, event.TlsVersion)
	}

	ebpf_tools.EnrichAddress(&tlsEvent.Client)
	ebpf_tools.EnrichAddress(&tlsEvent.Server)
	ebpfSocketFilter.Broker.TLSEvent(tlsEvent)
}

func intToIP4(ipNum uint32) string {
	ip := make(net.IP, 4)
	binary.BigEndian.PutUint32(ip, ipNum)
	return ip.String()
}

func isLittleEndian() bool {
	var a uint16 = 1

	return *(*byte)(unsafe.Pointer(&a)) == 1
}

func htons(a uint16) uint16 {
	if isLittleEndian() {
		var arr [2]byte
		binary.LittleEndian.PutUint16(arr[:], a)
		return binary.BigEndian.Uint16(arr[:])
	}
	return a
}
